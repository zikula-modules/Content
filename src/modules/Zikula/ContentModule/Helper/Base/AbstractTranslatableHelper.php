<?php
/**
 * Content.
 *
 * @copyright Axel Guckelsberger (Zikula)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Axel Guckelsberger <info@ziku.la>.
 * @link https://ziku.la
 * @version Generated by ModuleStudio 1.4.0 (https://modulestudio.de).
 */

namespace Zikula\ContentModule\Helper\Base;

use Gedmo\Loggable\LoggableListener;
use Symfony\Component\Form\FormInterface;
use Symfony\Component\HttpFoundation\RequestStack;
use Zikula\Common\Translator\TranslatorInterface;
use Zikula\Core\Doctrine\EntityAccess;
use Zikula\ExtensionsModule\Api\ApiInterface\VariableApiInterface;
use Zikula\SettingsModule\Api\ApiInterface\LocaleApiInterface;
use Zikula\ContentModule\Entity\Factory\EntityFactory;

/**
 * Helper base class for translatable methods.
 */
abstract class AbstractTranslatableHelper
{
    /**
     * @var TranslatorInterface
     */
    protected $translator;
    
    /**
     * @var RequestStack
     */
    protected $requestStack;
    
    /**
     * @var VariableApiInterface
     */
    protected $variableApi;
    
    /**
     * @var LocaleApiInterface
     */
    protected $localeApi;
    
    /**
     * @var EntityFactory
     */
    protected $entityFactory;
    
    /**
     * @var LoggableListener
     */
    protected $loggableListener;
    
    /**
     * TranslatableHelper constructor.
     *
     * @param TranslatorInterface $translator
     * @param RequestStack $requestStack
     * @param VariableApiInterface $variableApi
     * @param LocaleApiInterface $localeApi
     * @param EntityFactory $entityFactory
     */
    public function __construct(
        TranslatorInterface $translator,
        RequestStack $requestStack,
        VariableApiInterface $variableApi,
        LocaleApiInterface $localeApi,
        EntityFactory $entityFactory
    ) {
        $this->translator = $translator;
        $this->requestStack = $requestStack;
        $this->variableApi = $variableApi;
        $this->localeApi = $localeApi;
        $this->entityFactory = $entityFactory;
        $this->loggableListener = null;
    }
    
    /**
     * Return list of translatable fields per entity.
     * These are required to be determined to recognise
     * that they have to be selected from according translation tables.
     *
     * @param string $objectType The currently treated object type
     *
     * @return array List of translatable fields
     */
    public function getTranslatableFields($objectType)
    {
        $fields = [];
        switch ($objectType) {
            case 'page':
                $fields = ['title', 'metaDescription', 'optionalString1', 'optionalString2', 'optionalText', 'slug'];
                break;
            case 'contentItem':
                $fields = ['contentData', 'searchText', 'additionalSearchText'];
                break;
        }
    
        return $fields;
    }
    
    /**
     * Return the current language code.
     *
     * @return string code of current language
     */
    public function getCurrentLanguage()
    {
        return $this->requestStack->getCurrentRequest()->getLocale();
    }
    
    /**
     * Return list of supported languages on the current system.
     *
     * @param string $objectType The currently treated object type
     *
     * @return array List of language codes
     */
    public function getSupportedLanguages($objectType)
    {
        if ($this->variableApi->getSystemVar('multilingual')) {
            return $this->localeApi->getSupportedLocales();
        }
    
        // if multi language is disabled use only the current language
        return [$this->getCurrentLanguage()];
    }
    
    /**
     * Returns a list of mandatory fields for each supported language.
     *
     * @param string $objectType The currently treated object type
     *
     * @return array List of mandatory fields for each language code
     */
    public function getMandatoryFields($objectType)
    {
        $mandatoryFields = [];
        foreach ($this->getSupportedLanguages($objectType) as $language) {
            $mandatoryFields[$language] = [];
        }
    
        return $mandatoryFields;
    }
    
    /**
     * Collects translated fields for editing.
     *
     * @param EntityAccess $entity The entity being edited
     *
     * @return array Collected translations for each language code
     */
    public function prepareEntityForEditing($entity)
    {
        $translations = [];
        $objectType = $entity->get_objectType();
    
        if ($this->variableApi->getSystemVar('multilingual') != 1) {
            return $translations;
        }
    
        // check if there are any translated fields registered for the given object type
        $fields = $this->getTranslatableFields($objectType);
        if (!count($fields)) {
            return $translations;
        }
    
        // get translations
        $entityManager = $this->entityFactory->getEntityManager();
        $repository = $entityManager->getRepository('Zikula\ContentModule\Entity\\' . ucfirst($objectType) . 'TranslationEntity');
        $entityTranslations = $repository->findTranslations($entity);
    
        $supportedLanguages = $this->getSupportedLanguages($objectType);
        $currentLanguage = $this->getCurrentLanguage();
        foreach ($supportedLanguages as $language) {
            if ($language == $currentLanguage) {
                foreach ($fields as $fieldName) {
                    if (null === $entity[$fieldName]) {
                        $entity[$fieldName] = '';
                    }
                }
                // skip current language as this is not treated as translation on controller level
                continue;
            }
            $translationData = [];
            foreach ($fields as $fieldName) {
                $translationData[$fieldName] = isset($entityTranslations[$language][$fieldName]) ? $entityTranslations[$language][$fieldName] : '';
            }
            if (in_array($objectType, ['page']) && isset($translationData['slug'])) {
                $slugParts = explode('/', $translationData['slug']);
                $translationData['slug'] = end($slugParts);
            }
            // add data to collected translations
            $translations[$language] = $translationData;
        }
    
        return $translations;
    }
    
    /**
     * Post-editing method persisting translated fields.
     *
     * @param EntityAccess  $entity The entity being edited
     * @param FormInterface $form   Form containing translations
     */
    public function processEntityAfterEditing($entity, FormInterface $form)
    {
        $this->toggleLoggable(false);
    
        $objectType = $entity->get_objectType();
        $entityManager = $this->entityFactory->getEntityManager();
        $supportedLanguages = $this->getSupportedLanguages($objectType);
        foreach ($supportedLanguages as $language) {
            $translationInput = $this->readTranslationInput($form, $language);
            if (!count($translationInput)) {
                continue;
            }
    
            foreach ($translationInput as $fieldName => $fieldData) {
                $setter = 'set' . ucfirst($fieldName);
                $entity->$setter($fieldData);
            }
    
            $entity->setLocale($language);
            $entityManager->flush($entity);
        }
    
        $this->toggleLoggable(true);
    }
    
    /**
     * Collects translated fields from given form for a specific language.
     *
     * @param FormInterface $form     Form containing translations
     * @param string        $language The desired language
     *
     * @return array
     */
    public function readTranslationInput(FormInterface $form, $language = 'en')
    {
        $data = [];
        if (!isset($form['translations' . $language])) {
            return $data;
        }
        $translatedFields = $form['translations' . $language];
        foreach ($translatedFields as $fieldName => $formField) {
            $fieldData = $formField->getData();
            if (!$fieldData && isset($form[$fieldName])) {
                $fieldData = $form[$fieldName]->getData();
            }
            $data[$fieldName] = $fieldData;
        }
    
        return $data;
    }
    
    /**
     * Enables or disables the loggable listener to avoid log entries
     * for translation changes.
     *
     * @param boolean $enable True for enable, false for disable
     */
    public function toggleLoggable($enable = true)
    {
        $eventManager = $this->entityFactory->getEntityManager()->getEventManager();
        if (null === $this->loggableListener) {
            foreach ($eventManager->getListeners() as $event => $listeners) {
                foreach ($listeners as $hash => $listener) {
                    if ($listener instanceof LoggableListener) {
                        $this->loggableListener = $listener;
                        break 2;
                    }
                }
            }
        }
        if (null === $this->loggableListener) {
            return;
        }
    
        if (true === $enable) {
            $eventManager->addEventSubscriber($this->loggableListener);
        } else {
            $eventManager->removeEventSubscriber($this->loggableListener);
        }
    }
    
    /**
     * Sets values for translatable fields of given entity from it's stored
     * translation data.
     *
     * @param EntityAccess $entity Currently treated entity instance
     *
     * @return EntityAccess The processed entity instance
     */
    public function setEntityFieldsFromLogData($entity)
    {
        // check if this revision has translation data for current locale
        $translationData = $entity->getTranslationData();
        $language = $this->getCurrentLanguage();
        if (!isset($translationData[$language])) {
            return $entity;
        }
    
        $objectType = $entity->get_objectType();
        $translatableFields = $this->getTranslatableFields($objectType);
        foreach ($translatableFields as $fieldName) {
            if (!isset($translationData[$language][$fieldName])) {
                continue;
            }
            $setter = 'set' . ucfirst($fieldName);
            $entity->$setter($translationData[$language][$fieldName]);
        }
    
        return $entity;
    }
    
    /**
     * Removes all translations and persists them again for all
     * translatable fields of given entity from it's stored
     * translation data.
     *
     * The logic of this method is similar to processEntityAfterEditing above.
     *
     * @param EntityAccess $entity Currently treated entity instance
     */
    public function refreshTranslationsFromLogData($entity)
    {
        $this->toggleLoggable(false);
    
        $objectType = $entity->get_objectType();
    
        // remove all existing translations
        $entityManager = $this->entityFactory->getEntityManager();
        $translationClass = 'Zikula\ContentModule\Entity\\' . ucfirst($objectType) . 'TranslationEntity';
        $repository = $entityManager->getRepository($translationClass);
        $translationMeta = $entityManager->getClassMetadata($translationClass);
        $qb = $entityManager->createQueryBuilder();
        $qb->delete($translationMeta->rootEntityName, 'trans')
           ->where('trans.objectClass = :objectClass')
           ->andWhere('trans.foreignKey = :objectId')
           ->setParameter('objectClass', get_class($entity))
           ->setParameter('objectId', $entity->getKey())
        ;
        $query = $qb->getQuery();
        $query->execute();
    
        $translatableFields = $this->getTranslatableFields($objectType);
        $translationData = $entity->getTranslationData();
        $supportedLanguages = $this->getSupportedLanguages($objectType);
        foreach ($supportedLanguages as $language) {
            // check if this revision has translation data for current locale
            if (!isset($translationData[$language])) {
                continue;
            }
    
            foreach ($translatableFields as $fieldName) {
                if (!isset($translationData[$language][$fieldName])) {
                    continue;
                }
                $setter = 'set' . ucfirst($fieldName);
                $entity->$setter($translationData[$language][$fieldName]);
            }
    
            $entity->setLocale($language);
            $entityManager->flush($entity);
        }
    
        $this->toggleLoggable(true);
    }
}
